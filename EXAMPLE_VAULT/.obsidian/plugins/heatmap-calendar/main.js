/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => HeatmapCalendar
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  year: new Date().getFullYear(),
  defaultEntryIntensity: 4,
  colors: {
    default: ["#c6e48b", "#7bc96f", "#49af5d", "#2e8840", "#196127"]
  },
  entries: [{ date: "1900-01-01" }]
};
var HeatmapCalendar = class extends import_obsidian.Plugin {
  daysIntoYear(date) {
    return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
  }
  clamp(input, min, max) {
    return input < min ? min : input > max ? max : input;
  }
  map(current, in_min, in_max, out_min, out_max) {
    const mapped = (current - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    return this.clamp(mapped, out_min, out_max);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      window.renderHeatmapCalendar = (el, calendarData) => {
        var _a, _b, _c, _d, _e;
        const year = (_a = calendarData.year) != null ? _a : this.settings.year;
        const colors = (_b = calendarData.colors) != null ? _b : this.settings.colors;
        const calEntries = (_c = calendarData.entries) != null ? _c : this.settings.entries;
        const intensities = [];
        calEntries.forEach((e) => {
          if (e.intensity) {
            intensities.push(e.intensity);
          }
        });
        const minimumIntensity = (_d = Math.min(...intensities)) != null ? _d : 1;
        const maximumIntensity = (_e = Math.max(...intensities)) != null ? _e : 5;
        const mappedEntries = [];
        calEntries.forEach((e) => {
          var _a2;
          if (new Date(e.date).getFullYear() == year) {
            const newEntry = __spreadValues({}, e);
            newEntry.intensity = (_a2 = e.intensity) != null ? _a2 : this.settings.defaultEntryIntensity;
            if (minimumIntensity == maximumIntensity) {
              newEntry.intensity = 5;
            } else {
              newEntry.intensity = Math.round(this.map(newEntry.intensity, minimumIntensity, maximumIntensity, 1, 5));
            }
            mappedEntries[this.daysIntoYear(new Date(e.date))] = newEntry;
          }
        });
        const firstDayOfYear = new Date(Date.UTC(year, 0, 1));
        let numberOfEmptyDaysBeforeYearBegins = (firstDayOfYear.getDay() + 5) % 6;
        let boxes = "";
        while (numberOfEmptyDaysBeforeYearBegins) {
          boxes += `<li style="background-color: transparent"></li>`;
          numberOfEmptyDaysBeforeYearBegins--;
        }
        const lastDayOfYear = new Date(Date.UTC(year, 11, 31));
        const numberOfDays = this.daysIntoYear(lastDayOfYear);
        for (let day = 1; day <= numberOfDays; day++) {
          let background_color, content = "";
          if (mappedEntries[day]) {
            if (mappedEntries[day].color) {
              background_color = colors[mappedEntries[day].color][mappedEntries[day].intensity - 1];
            } else {
              background_color = colors[Object.keys(colors)[0]][mappedEntries[day].intensity - 1];
            }
            if (mappedEntries[day].content) {
              content = mappedEntries[day].content;
            }
            boxes += `<li style="background-color:${background_color};">${content}</li>`;
          } else {
            boxes += `<li></li>`;
          }
        }
        const html = `
				<div class="heatmap-calendar-graph">
				<div class="heatmap-calendar-year">${String(year).slice(2)}</div>
				<ul class="heatmap-calendar-months">
					<li>Jan</li>
					<li>Feb</li>
					<li>Mar</li>
					<li>Apr</li>
					<li>May</li>
					<li>Jun</li>
					<li>Jul</li>
					<li>Aug</li>
					<li>Sep</li>
					<li>Oct</li>
					<li>Nov</li>
					<li>Dec</li>
				</ul>
				<ul class="heatmap-calendar-days">
					<li>Mon</li>
					<li>Tue</li>
					<li>Wed</li>
					<li>Thu</li>
					<li>Fri</li>
					<li>Sat</li>
					<li>Sun</li>
				</ul>
				<ul class="heatmap-calendar-boxes">
					${boxes}
				</ul>
				</div>
			`;
        el.insertAdjacentHTML("beforeend", html);
      };
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuLy8gVE9ETzogYmxhbmRlIGZhcmdhIG9tIG1hbiBicnVrYSB0byBmYXJnYSBpIGVuIGV2ZW50P1xyXG4vLyBUT0RPOiBjdXN0b20gZml4ZWQgc2NhbGUgaXN0ZWRlbmZvciBhdXRvbWFwXHJcbi8vIENvdWxkRE86IGxhZ2EgdmlzdWVsbCBzY2FsYSB1bmRlciwgbWUgbWluIG1heCBhdmcgdGV4dFxyXG4vLyBDb3VsZERPOiBrb25uZSBsZWdnZSB0aWwgc28gbW9uZ2UgZmFyZ2EgbWFuIHZpbCBpIGNvbG9ycyBhcnJheSBcclxuXHJcbmludGVyZmFjZSBIZWF0bWFwQ2FsZW5kYXJTZXR0aW5ncyB7XHJcblx0eWVhcjogbnVtYmVyO1xyXG5cdGRlZmF1bHRFbnRyeUludGVuc2l0eTogbnVtYmVyO1xyXG5cdGNvbG9yczoge1xyXG5cdFx0ZGVmYXVsdDogQXJyYXk8c3RyaW5nPjtcclxuXHR9O1xyXG5cdGVudHJpZXM6IEFycmF5PEVudHJ5PjtcclxufVxyXG5cclxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogSGVhdG1hcENhbGVuZGFyU2V0dGluZ3MgPSB7XHJcblx0eWVhcjogbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLFxyXG5cdGRlZmF1bHRFbnRyeUludGVuc2l0eTogNCxcclxuXHRjb2xvcnM6IHtcclxuXHRcdGRlZmF1bHQ6IFtcIiNjNmU0OGJcIiwgXCIjN2JjOTZmXCIsIFwiIzQ5YWY1ZFwiLCBcIiMyZTg4NDBcIiwgXCIjMTk2MTI3XCJdXHJcblx0fSxcclxuXHRlbnRyaWVzOiBbeyBkYXRlOiBcIjE5MDAtMDEtMDFcIiB9XVxyXG59XHJcblxyXG5pbnRlcmZhY2UgRW50cnkge1xyXG5cdGRhdGU6IHN0cmluZztcclxuXHRpbnRlbnNpdHk/OiBudW1iZXI7XHJcblx0Y29sb3I/OiBzdHJpbmcgfCBudW1iZXI7XHJcblx0Y29udGVudD86IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIENhbGVuZGFyRGF0YSB7XHJcblx0eWVhcj86IG51bWJlcjtcclxuXHRjb2xvcnM/OiB7XHJcblx0XHRbaW5kZXg6IHN0cmluZyB8IG51bWJlcl06IHtcclxuXHRcdFx0W2luZGV4OiBudW1iZXJdOiBzdHJpbmc7XHJcblx0XHR9O1xyXG5cdH07XHJcblx0ZW50cmllcz86IEFycmF5PEVudHJ5PjtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhdG1hcENhbGVuZGFyIGV4dGVuZHMgUGx1Z2luIHtcclxuXHJcblx0c2V0dGluZ3M6IEhlYXRtYXBDYWxlbmRhclNldHRpbmdzO1xyXG5cclxuXHRkYXlzSW50b1llYXIoZGF0ZTogRGF0ZSk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQoRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKSAtXHJcblx0XHRcdFx0RGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKSkgLyAyNCAvIDYwIC8gNjAgLyAxMDAwXHJcblx0XHQpXHJcblx0fVxyXG5cclxuXHRjbGFtcChpbnB1dDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIGlucHV0IDwgbWluID8gbWluIDogaW5wdXQgPiBtYXggPyBtYXggOiBpbnB1dDtcclxuXHR9XHJcblxyXG5cdG1hcChjdXJyZW50OiBudW1iZXIsIGluX21pbjogbnVtYmVyLCBpbl9tYXg6IG51bWJlciwgb3V0X21pbjogbnVtYmVyLCBvdXRfbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgbWFwcGVkOiBudW1iZXIgPSAoKGN1cnJlbnQgLSBpbl9taW4pICogKG91dF9tYXggLSBvdXRfbWluKSkgLyAoaW5fbWF4IC0gaW5fbWluKSArIG91dF9taW47XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFtcChtYXBwZWQsIG91dF9taW4sIG91dF9tYXgpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0Ly9AdHMtaWdub3JlXHJcblx0XHR3aW5kb3cucmVuZGVySGVhdG1hcENhbGVuZGFyID0gKGVsOiBIVE1MRWxlbWVudCwgY2FsZW5kYXJEYXRhOiBDYWxlbmRhckRhdGEpOiB2b2lkID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHllYXIgPSBjYWxlbmRhckRhdGEueWVhciA/PyB0aGlzLnNldHRpbmdzLnllYXJcclxuXHRcdFx0Y29uc3QgY29sb3JzID0gY2FsZW5kYXJEYXRhLmNvbG9ycyA/PyB0aGlzLnNldHRpbmdzLmNvbG9yc1xyXG5cdFx0XHRjb25zdCBjYWxFbnRyaWVzID0gY2FsZW5kYXJEYXRhLmVudHJpZXMgPz8gdGhpcy5zZXR0aW5ncy5lbnRyaWVzXHJcblxyXG5cdFx0XHRjb25zdCBpbnRlbnNpdGllczogQXJyYXk8bnVtYmVyPiA9IFtdXHJcblx0XHRcdGNhbEVudHJpZXMuZm9yRWFjaChlID0+IHtcclxuXHRcdFx0XHRpZiAoZS5pbnRlbnNpdHkpIHtcclxuXHRcdFx0XHRcdGludGVuc2l0aWVzLnB1c2goZS5pbnRlbnNpdHkpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cclxuXHRcdFx0Y29uc3QgbWluaW11bUludGVuc2l0eSA9IE1hdGgubWluKC4uLmludGVuc2l0aWVzKSA/PyAxO1xyXG5cdFx0XHQvL2NvbnN0IGF2ZXJhZ2VJbnRlbnNpdHkgPSBpbnRlbnNpdGllcy5yZWR1Y2UoKGEsYikgPT4gYSArIGIsIDApIC8gaW50ZW5zaXRpZXMubGVuZ3RoID8/IDNcclxuXHRcdFx0Y29uc3QgbWF4aW11bUludGVuc2l0eSA9IE1hdGgubWF4KC4uLmludGVuc2l0aWVzKSA/PyA1O1xyXG5cclxuXHRcdFx0Y29uc3QgbWFwcGVkRW50cmllczogQXJyYXk8RW50cnk+ID0gW11cclxuXHJcblx0XHRcdGNhbEVudHJpZXMuZm9yRWFjaChlID0+IHtcclxuXHRcdFx0XHRpZiAobmV3IERhdGUoZS5kYXRlKS5nZXRGdWxsWWVhcigpID09IHllYXIpIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBuZXdFbnRyeSA9IHsgLi4uZSB9XHJcblx0XHRcdFx0XHRuZXdFbnRyeS5pbnRlbnNpdHkgPSBlLmludGVuc2l0eSA/PyB0aGlzLnNldHRpbmdzLmRlZmF1bHRFbnRyeUludGVuc2l0eTtcclxuXHJcblx0XHRcdFx0XHRpZiAobWluaW11bUludGVuc2l0eSA9PSBtYXhpbXVtSW50ZW5zaXR5KSB7XHJcblx0XHRcdFx0XHRcdG5ld0VudHJ5LmludGVuc2l0eSA9IDU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRuZXdFbnRyeS5pbnRlbnNpdHkgPSBNYXRoLnJvdW5kKHRoaXMubWFwKG5ld0VudHJ5LmludGVuc2l0eSwgbWluaW11bUludGVuc2l0eSwgbWF4aW11bUludGVuc2l0eSwgMSwgNSkpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRtYXBwZWRFbnRyaWVzW3RoaXMuZGF5c0ludG9ZZWFyKG5ldyBEYXRlKGUuZGF0ZSkpXSA9IG5ld0VudHJ5XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cclxuXHRcdFx0Y29uc3QgZmlyc3REYXlPZlllYXIgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCAxKSlcclxuXHRcdFx0bGV0IG51bWJlck9mRW1wdHlEYXlzQmVmb3JlWWVhckJlZ2lucyA9IChmaXJzdERheU9mWWVhci5nZXREYXkoKSArIDUpICUgNlxyXG5cdFx0XHRsZXQgYm94ZXMgPSBcIlwiXHJcblx0XHRcdHdoaWxlIChudW1iZXJPZkVtcHR5RGF5c0JlZm9yZVllYXJCZWdpbnMpIHtcclxuXHRcdFx0XHRib3hlcyArPSBgPGxpIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnRcIj48L2xpPmBcclxuXHRcdFx0XHRudW1iZXJPZkVtcHR5RGF5c0JlZm9yZVllYXJCZWdpbnMtLVxyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnN0IGxhc3REYXlPZlllYXIgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAxMSwgMzEpKVxyXG5cdFx0XHRjb25zdCBudW1iZXJPZkRheXMgPSB0aGlzLmRheXNJbnRvWWVhcihsYXN0RGF5T2ZZZWFyKSAvL2VnIDM2NSBvciAzNjZcclxuXHJcblx0XHRcdGZvciAobGV0IGRheSA9IDE7IGRheSA8PSBudW1iZXJPZkRheXM7IGRheSsrKSB7XHJcblxyXG5cdFx0XHRcdGxldCBiYWNrZ3JvdW5kX2NvbG9yLCBjb250ZW50ID0gXCJcIlxyXG5cclxuXHRcdFx0XHRpZiAobWFwcGVkRW50cmllc1tkYXldKSB7XHJcblx0XHRcdFx0XHRpZiAobWFwcGVkRW50cmllc1tkYXldLmNvbG9yKSB7XHJcblx0XHRcdFx0XHRcdGJhY2tncm91bmRfY29sb3IgPSBjb2xvcnNbbWFwcGVkRW50cmllc1tkYXldLmNvbG9yXVttYXBwZWRFbnRyaWVzW2RheV0uaW50ZW5zaXR5IC0gMV1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGJhY2tncm91bmRfY29sb3IgPSBjb2xvcnNbT2JqZWN0LmtleXMoY29sb3JzKVswXV1bbWFwcGVkRW50cmllc1tkYXldLmludGVuc2l0eSAtIDFdXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobWFwcGVkRW50cmllc1tkYXldLmNvbnRlbnQpIHtcclxuXHRcdFx0XHRcdFx0Y29udGVudCA9IG1hcHBlZEVudHJpZXNbZGF5XS5jb250ZW50XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRib3hlcyArPSBgPGxpIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke2JhY2tncm91bmRfY29sb3J9O1wiPiR7Y29udGVudH08L2xpPmBcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ym94ZXMgKz0gYDxsaT48L2xpPmBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3QgaHRtbCA9IGBcclxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGVhdG1hcC1jYWxlbmRhci1ncmFwaFwiPlxyXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJoZWF0bWFwLWNhbGVuZGFyLXllYXJcIj4ke1N0cmluZyh5ZWFyKS5zbGljZSgyKX08L2Rpdj5cclxuXHRcdFx0XHQ8dWwgY2xhc3M9XCJoZWF0bWFwLWNhbGVuZGFyLW1vbnRoc1wiPlxyXG5cdFx0XHRcdFx0PGxpPkphbjwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+RmViPC9saT5cclxuXHRcdFx0XHRcdDxsaT5NYXI8L2xpPlxyXG5cdFx0XHRcdFx0PGxpPkFwcjwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+TWF5PC9saT5cclxuXHRcdFx0XHRcdDxsaT5KdW48L2xpPlxyXG5cdFx0XHRcdFx0PGxpPkp1bDwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+QXVnPC9saT5cclxuXHRcdFx0XHRcdDxsaT5TZXA8L2xpPlxyXG5cdFx0XHRcdFx0PGxpPk9jdDwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+Tm92PC9saT5cclxuXHRcdFx0XHRcdDxsaT5EZWM8L2xpPlxyXG5cdFx0XHRcdDwvdWw+XHJcblx0XHRcdFx0PHVsIGNsYXNzPVwiaGVhdG1hcC1jYWxlbmRhci1kYXlzXCI+XHJcblx0XHRcdFx0XHQ8bGk+TW9uPC9saT5cclxuXHRcdFx0XHRcdDxsaT5UdWU8L2xpPlxyXG5cdFx0XHRcdFx0PGxpPldlZDwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+VGh1PC9saT5cclxuXHRcdFx0XHRcdDxsaT5Gcmk8L2xpPlxyXG5cdFx0XHRcdFx0PGxpPlNhdDwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+U3VuPC9saT5cclxuXHRcdFx0XHQ8L3VsPlxyXG5cdFx0XHRcdDx1bCBjbGFzcz1cImhlYXRtYXAtY2FsZW5kYXItYm94ZXNcIj5cclxuXHRcdFx0XHRcdCR7Ym94ZXN9XHJcblx0XHRcdFx0PC91bD5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0YFxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKGh0bWwpXHJcblx0XHRcdGVsLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBodG1sKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9udW5sb2FkKCkge1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUF1QjtBQWdCdkIsSUFBTSxtQkFBNEM7QUFBQSxFQUNqRCxNQUFNLElBQUksT0FBTztBQUFBLEVBQ2pCLHVCQUF1QjtBQUFBLEVBQ3ZCLFFBQVE7QUFBQSxJQUNQLFNBQVMsQ0FBQyxXQUFXLFdBQVcsV0FBVyxXQUFXO0FBQUE7QUFBQSxFQUV2RCxTQUFTLENBQUMsRUFBRSxNQUFNO0FBQUE7QUFvQm5CLG9DQUE2Qyx1QkFBTztBQUFBLEVBSW5ELGFBQWEsTUFBb0I7QUFDaEMsV0FDRSxNQUFLLElBQUksS0FBSyxlQUFlLEtBQUssWUFBWSxLQUFLLGFBQ25ELEtBQUssSUFBSSxLQUFLLGVBQWUsR0FBRyxNQUFNLEtBQUssS0FBSyxLQUFLO0FBQUE7QUFBQSxFQUl4RCxNQUFNLE9BQWUsS0FBYSxLQUFxQjtBQUN0RCxXQUFPLFFBQVEsTUFBTSxNQUFNLFFBQVEsTUFBTSxNQUFNO0FBQUE7QUFBQSxFQUdoRCxJQUFJLFNBQWlCLFFBQWdCLFFBQWdCLFNBQWlCLFNBQXlCO0FBQzlGLFVBQU0sU0FBbUIsV0FBVSxVQUFXLFdBQVUsV0FBYSxVQUFTLFVBQVU7QUFDeEYsV0FBTyxLQUFLLE1BQU0sUUFBUSxTQUFTO0FBQUE7QUFBQSxFQUc5QixTQUFTO0FBQUE7QUFFZCxZQUFNLEtBQUs7QUFHWCxhQUFPLHdCQUF3QixDQUFDLElBQWlCLGlCQUFxQztBQW5FeEY7QUFxRUcsY0FBTSxPQUFPLG1CQUFhLFNBQWIsWUFBcUIsS0FBSyxTQUFTO0FBQ2hELGNBQU0sU0FBUyxtQkFBYSxXQUFiLFlBQXVCLEtBQUssU0FBUztBQUNwRCxjQUFNLGFBQWEsbUJBQWEsWUFBYixZQUF3QixLQUFLLFNBQVM7QUFFekQsY0FBTSxjQUE2QjtBQUNuQyxtQkFBVyxRQUFRLE9BQUs7QUFDdkIsY0FBSSxFQUFFLFdBQVc7QUFDaEIsd0JBQVksS0FBSyxFQUFFO0FBQUE7QUFBQTtBQUlyQixjQUFNLG1CQUFtQixXQUFLLElBQUksR0FBRyxpQkFBWixZQUE0QjtBQUVyRCxjQUFNLG1CQUFtQixXQUFLLElBQUksR0FBRyxpQkFBWixZQUE0QjtBQUVyRCxjQUFNLGdCQUE4QjtBQUVwQyxtQkFBVyxRQUFRLE9BQUs7QUF0RjNCO0FBdUZJLGNBQUksSUFBSSxLQUFLLEVBQUUsTUFBTSxpQkFBaUIsTUFBTTtBQUUzQyxrQkFBTSxXQUFXLG1CQUFLO0FBQ3RCLHFCQUFTLFlBQVksU0FBRSxjQUFGLGFBQWUsS0FBSyxTQUFTO0FBRWxELGdCQUFJLG9CQUFvQixrQkFBa0I7QUFDekMsdUJBQVMsWUFBWTtBQUFBLG1CQUNmO0FBQ04sdUJBQVMsWUFBWSxLQUFLLE1BQU0sS0FBSyxJQUFJLFNBQVMsV0FBVyxrQkFBa0Isa0JBQWtCLEdBQUc7QUFBQTtBQUVyRywwQkFBYyxLQUFLLGFBQWEsSUFBSSxLQUFLLEVBQUUsVUFBVTtBQUFBO0FBQUE7QUFJdkQsY0FBTSxpQkFBaUIsSUFBSSxLQUFLLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFDbEQsWUFBSSxvQ0FBcUMsZ0JBQWUsV0FBVyxLQUFLO0FBQ3hFLFlBQUksUUFBUTtBQUNaLGVBQU8sbUNBQW1DO0FBQ3pDLG1CQUFTO0FBQ1Q7QUFBQTtBQUVELGNBQU0sZ0JBQWdCLElBQUksS0FBSyxLQUFLLElBQUksTUFBTSxJQUFJO0FBQ2xELGNBQU0sZUFBZSxLQUFLLGFBQWE7QUFFdkMsaUJBQVMsTUFBTSxHQUFHLE9BQU8sY0FBYyxPQUFPO0FBRTdDLGNBQUksa0JBQWtCLFVBQVU7QUFFaEMsY0FBSSxjQUFjLE1BQU07QUFDdkIsZ0JBQUksY0FBYyxLQUFLLE9BQU87QUFDN0IsaUNBQW1CLE9BQU8sY0FBYyxLQUFLLE9BQU8sY0FBYyxLQUFLLFlBQVk7QUFBQSxtQkFDN0U7QUFDTixpQ0FBbUIsT0FBTyxPQUFPLEtBQUssUUFBUSxJQUFJLGNBQWMsS0FBSyxZQUFZO0FBQUE7QUFFbEYsZ0JBQUksY0FBYyxLQUFLLFNBQVM7QUFDL0Isd0JBQVUsY0FBYyxLQUFLO0FBQUE7QUFFOUIscUJBQVMsK0JBQStCLHNCQUFzQjtBQUFBLGlCQUN4RDtBQUNOLHFCQUFTO0FBQUE7QUFBQTtBQUdYLGNBQU0sT0FBTztBQUFBO0FBQUEseUNBRXlCLE9BQU8sTUFBTSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0F5QnJEO0FBQUE7QUFBQTtBQUFBO0FBS0osV0FBRyxtQkFBbUIsYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLFdBQVc7QUFBQTtBQUFBLEVBSUwsZUFBZTtBQUFBO0FBQ3BCLFdBQUssV0FBVyxPQUFPLE9BQU8sSUFBSSxrQkFBa0IsTUFBTSxLQUFLO0FBQUE7QUFBQTtBQUFBLEVBRzFELGVBQWU7QUFBQTtBQUNwQixZQUFNLEtBQUssU0FBUyxLQUFLO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=
